<!DOCTYPE html>
<html lang="en" data-random-animation="false" data-animation="36">
    <head>
        <!--Meta Tags-->
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="keywords" content="Harleigh Abel, atxrenegade, full stack web developer, portfolio, resume" />
        <meta name="description" content="Digital Resume for Harleigh Abel /atxrenegade / Full Stack Web Developer " />

        <!--Page Title-->
        <title>Harleigh Abel - atxrenegade - Digital Resume - Full Stack Web Developer </title>

        <!--Plugins Css-->
        <link rel="stylesheet" href="css/plugins.css">
        <!--Main Styles Css-->
        <link rel="stylesheet" href="css/style-light.css">

        <link rel="stylesheet" href="css/blue-color.css">

        <script src="js/modernizr.js"></script>

        <!--Favicons-->
        <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon">

    </head>

    <body>

    <!--Preloader Start-->
    <div class="preloader">
        <div class="loader">
            <h4>Harleigh Abel</h4>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>
    <!--Preloader End-->


    <div id="page">

        <!--Header Start-->
        <header>
            <div class="header-content">

                <!--Mobile Header-->
                <div class="header-mobile">
                    <a class="header-toggle"><i class="fas fa-bars"></i></a>
                    <h2>Harleigh Abel</h2>
                </div>

                <!--Main Header-->
                <div class="header-main" data-simplebar>
                    <div class="image-container">
                        <h2 class="header-name">Harleigh Abel</h2>
                        <img src="img/Harleigh_Abel_picture.png" alt="Harleigh-Abel-profile-pic">
                    </div>

                    <!--Nav Menus-->
                    <nav class="nav-menu">
                        <ul>
                            <li><a href="index.html#home"><span class="nav-menu-icon"><i class="lnr lnr-home"></i></span>Home </a> </li>
                            <li><a href="index.html#about"><span class="nav-menu-icon"><i class="lnr lnr-user"></i></span>About Me</a></li>
                            <li><a href="index.html#resume"><span class="nav-menu-icon"><i class="lnr lnr-license"></i></span>Resume</a></li>
                            <li><a href="index.html#portfolio"><span class="nav-menu-icon"><i class="lnr lnr-briefcase"></i></span>Portfolio</a></li>
                            <li><a href="index.html#blog" class="active"><span class="nav-menu-icon"><i class="lnr lnr-book"></i></span>Blog</a></li>
                            <li><a href="index.html#contact"><span class="nav-menu-icon"><i class="lnr lnr-envelope"></i></span>Contact</a></li>
                        </ul>
                    </nav>

                    <!--Nav Footer-->
                    <div class="nav-footer">
                        <!--Social Links-->
                        <ul class="social">
                            <li><a href="https://github.com/atxrenegade"><i class="fab fa-github"></i></a></li>
                            <li><a href="https://www.linkedin.com/in/harleigh-abel-8aaa1a64/"><i class="fab fa-linkedin"></i></a></li>
                            <li><a href="https://dev.to/atxrenegade"><i class="fab fa-dev"></i></a></li>
                            <li><a href="https://www.youtube.com/playlist?list=PLV5GLSDMs4v_ZDV8TqSkQNIKYP8Qyk33d"><i
                                        class="fab fa-youtube-square"></i></a></li>
                        </ul>
                        <!--Copyright Text-->
                        <div class="copy">
                            <p>2020 &copy; atxrenegade.<br>All Right Reserved.</p>
                            <!-- Template credit to Cosmos-Themes -->
                        </div>
                    </div>
                </div>
            </div>
        </header>
        <!--Header End-->


        <!--Main Start-->
        <div id="main" class="site-main">
            <div class="blog-page">
                <div class="blog-image">
                    <img class='img-large' src='/img/blog/javascript.jpg' alt='Coding in Javascript'>
                </div>
                <div class="blog-container">
                    <div class="row">

                        <!--Blog Heading Start-->
                        <div class="blog-heading col-md-8 offset-md-2">
                            <span class="cat">Software Development</span>
                            <h2>JS Under the Hood - The Fuzzy Parts</h2
                            <span class="blog-date"> May 15 2020</span>
                        </div>

                        <!--Blog Content Start-->
                        <div class="blog-content col-md-10 offset-md-1">
                            <h2>Understanding JIT Comp, Scopes, Closures, Hoisting, Shadowing, THIS, & the Module Pattern</h2><br>
                            27 min read<br>
                            #javascript #html5 #SPA #responsive #flatiron #webdev<br><br>

                            <h4> Some of the topics explored in this post: </h4>
                            <ul><br>
                                <li>&bull;Understanding Just-In-Time Compilation</li>
                                <li>&bull;Exploring Scopes, Closures, Hoisting, and Shadowing</li>
                                <li>&bull;Comparing Variable and Function Behavior and Types</li>
                                <li>&bull;Implicit vs Explicit - Rules of Precedence for determining THIS</li>
                                <li>&bull;The Principle of Least Exposure (POLE)</li>
                                <li>&bull;Review of the Classic Module Pattern and the ES Module Format</li>
                            </ul>
                        
                            <br>
                            <p>Check back Friday, June 29th, 2020 for the full blog post!</p>
                            <br>
                            <h2>Correcting Distorted Mental Models</h2>
                            <p>After discovering some misguided mental models in my understanding of some of the more opaque idiosyncrasies of
                            JavaScript I was directed towards Kyle Simpson's infamous and invaluable series "You Don't Know JS" (specifically the
                            'Scope and Closures' volume). I highly recommend a thorough consumption of each of these books to any developer who plans to spend any amount of time working with the rapidly transforming language of JavaScript for a solid grasp of some of these often misunderstood and miscommunicated concepts. I hope I can do it some justice in clarifying and communicating some of those concepts here.</p>
                    
                            <p>I am a full picture person, I retain details best when I have a complete picture, an aerial view, a deep exploration of low level concepts. But this is the real world and in development we often don't get time for contemplation and review, so I savor it when I can. Here's my Reader Digest version of mulling over Kyle's book(3 x for good measure), Stack Overflow posts, YouTube videos, Wikipedia (surprisingly), medium, Dev.to, GitHub repos and a dozen of other sources. Some of the specific misconceptions I was looking to clarify were hoisting, the use vs banishment of var, closures, and the mystical JIT compilation process. Much of what I discovered contradicted what I had originally been taught, but these new arguments were backed with compelling logic from experienced developers and convincing code samples that altered the way I view, and currently use JS language and features. So let's dive in.</p>
                            <br>
                            <h2>Compiled vs Interpreted</h2>
                            <p>For machines to understand high level languages like JavaScript the code must be translated or complied into to machine code. Compilation is a process in which the compiler converts higher level source code into an machine language
                            executable file in a build step before runtime. Interpreted languages are translated at runtime line by line while the source code is converted to machine code during execution. There are arguments for and against each format. Compiled
                            code is faster to execute because the build step occurs prior to runtime, the entire program has already been checked for errors and the work of converting to machine code is already complete. Interpreted code is more flexible to correct, it runs line by line, often displaying errors as they occur, and takes less memory.</p>
                            
                            <p>But why do we care? Isn't JavaScript an interpreted language? It was... in the beginning, but modern day JavaScript engines use a refined combination of compilation and interpretation commonly referred to as just-in-time compilation (aka JIT compilation). Understanding the way our code is processed during compilation and execution will help us get a clearer understanding of scopes, variables and their behavior, and of when these objects are determined and available for use in our code. By having a deeper understanding of these concepts we can use this knowledge to replace
                            memorization of misleading, incomplete, and outdated mental models. Remember these are highly level summaries of complex processes simplified for basic comprehension.</p>
                            <br>
                            <h2> JS Engine and the Runtime Environment</h2>
                            <p>There are two important components involved at runtime, the JavaScript engine, and the runtime environment that the
                            engine operates within. Each browser uses it's own engine as they compete for speed and efficiency. You've probably
                            heard of the popular ones, V8 for Google Chrome, Karma for Internet Explorer, Nitro for Safari and Firefox( Developer
                            Edition - my personal preference) uses Spider Monkey. While JS can still be executed with an interpreter, it is more commonly processes by these browsers and their fine tuned engines using complex processes for asynchronously compiling, optimizing and executing source code through multiple threads within the runtime environment.</p>
                            
                            <p>So what is the runtime environment? The runtime environment, is the environment that your code is executed in. It is generally the collection of libraries, tools, and support systems available within the runtime space. Some of these
                            tools and services include the server environment, your desktop environment, the browser, the js engine, the core
                            library, etc.. This also where the event loop is implemented.</p>
                            <br>
                            <h2>Three Stage Compilation</h2>
                            <p>Now that we understand that JS uses a combination of both compilation and interpretation known as "just in time
                            compiling", we are going to take a closer look at the compilation phase to better understand scope and variable
                            behavior. Again, compilation is preprocessing of source code into machine code, it is during this phase that JS engine creates a map of scopes and identifiers that determine the availability of our functions and variables. In JavaScript
                            the compilation of our code occurs literal nanoseconds before the engines executes the translated code, so in order to facilitate this process it is broken down into three stages:</p>
                            <ul>
                                <li>&bull; Stage One: Tokenizing/Lexing</li>
                                <li>&bull; Stage Two: Parsing</li>
                                <li>&bull; Stage three: Code Generation</li>
                            </ul>
                            <p>In the first stage of compilation, lexical analysis and tokenizing refers to the process in which the engine analyzes our syntax and breaks it down into 'tokens'. Tokens are just strings with assigned meanings we recognize them as identifiers, keywords, operators, literals, comments, etc.  Once the source code has been lexed/tokenized, the engine parses the code to create an abstract tree representation (AST). The AST is a data structure that tells our compiler...</p>

                            <!--- insert the rest of the blog post here!        -->
                            <br>
                            <h2>This, This, This or This</h2>
                            
                            <p>The use of the keyword this is a concept that often trips up and mystifies new developers. The common misconception is that THIS is a reference to the function itself, OR to the lexical scope of the function being called on the THIS object, but THIS is actually a runtime binding determined by the call site that creates an execution context for the life of that THIS instance. In other words THIS is kind of like a post-it note we stick to a js object to let our program know what THIS is referring to. In order to determine what THIS is referring to, we need to examine the point in our code where our THIS was attached to our object, aka the call site. There are multiple ways to configure our THIS binding, and since more that one determining variation can appear at the same call site, we need to recognize and understand the hierarchy that applies when to the THIS binding rules. In order from highest precedence to lowest precedence the four rules for determining what our THIS binding context is are:</p> 
                            <ol>
                                <li>The NEW constructor keyword</li>
                                <li>explicit binding</li>
                                <li>implicit binding</li> 
                                <li>default binding</li>
                            </ol>
                            <p>Let's explore how each of these execution contexts are
                            determined and the syntax used to implement them.</p>
                            
                            <h3>THIS by Default</h3>
                            
                            <p>Starting from the bottom up, the default rule is in effect when none of the other cases apply to our call site. If our THIS instance is not using implicit or explicit binding, or the NEW constructor keyword, then the default THIS behavior will be determined by whether or not the CONTENTS of the function are running in strict mode. If strict mode has not been applied to our function then our THIS binding will refer to the global object. If our function IS running in strict mode then the global object becomes unavailable and the value of THIS is set to 'undefined';</p>
                            
                            ```
                            code sample - use strict
                            code sample - non use strict
                            
                            ```
                            
                            <h3>Implicitly THIS</h3>
                            <p>Implicit execution contexts are determined the same way the dot operator function call operated. When we call a function using the dot operator we look to the left of the dot to determine what object we are invoking the function on. In the case of implicit binding to the THIS keyword, we determine ownership of the execution context by investigating the call-site in the same way, in more complex cases where multiple properties are chained together only the last level, the final property is the determinant.</p>
                            
                            <p>Word of caution with the use of implicit bindings. This binding type easily falls back to the default object and
                            unintentionally resets when it loses it implicit binding. We can prevent this by creating hard bindings with explicit
                            context with the bind() function.</p>
                            
                            implicit code sample
                            
                            <h3>Explicitly THIS - Bind, Call and Apply</h3>
                            <p>THIS can be explicitly set to the object of our choice by using one of three popular methods bind(), call(), or apply().  Each of these important tools work similarly with slight variations in parameter expectations and return values. The first parameter passe into each of these functions will be the object we intend to explicitly set as our execution context. If you decide to pass in a primitive value (such a string or integer) instead the value will be auto-boxed to create the object parameter is the function expects. Autoboxing is when we pass a primitive data type like an integer or a string into a method that is expecting and object and it automatically 'wraps; our argument in an object for us.</p>
                            
                            Autoboxing syntax example

                            <p>>These functions are useful when we want to create methods that can be used on different objects, they give us the control to specify what context we are binding the original method to, the initial arguments passed in to upon
                            invocation, and the option to create a brand new method bound to our object through hard bindings without mutating the original object or function.</p
                            
                            <p>The call() method takes two or more parameters as an argument list, the first parameter is the THIS context we are explicitly binding to the call method, and the remaining parameters are the arguments we would like to pass into the call() method which immediately invokes the function being called with these arguments.</p>
                            
                            <p>The apply() method is virtually identical to the call() and is also used to explicitly bind our execution context to our object and pass arguments to a function being executing on the specified object, the ONLY difference between call() and apply(), is that instead of accepting multiple parameters for additional arguments, the apply() method takes this additional parameters as a single array; The return values for call and apply is the result of the method called on on our bound object with the specified parameters.</p>
                            
                            <p>The bind() method is a another close, relative of call() and apply(). It is also used to explicitly bind our THIS
                            context and the first parameter is again our intended object for execution context, and the following parameters are again a list of arguments we are passing to the function being invoked, but instead of being invoked immediately as with call() and apply(), a new function is created and returned with the provided parameters hard coded into the newly created function(aka as 'hard binding') the argument list while passed into the new function before any new arguments passed in at execution time.</p>
                            
                            <pre></pre>
                            explicit code sample
                            
                            <h3>A brand NEW THIS</h3>
                            <p>The easiest rule to identify is the use of the NEW constructor. The NEW keyword creates a new javascript object that THIS binds to for the duration of the constructor call. These will return our newly created objects automatically unless another return value has been specified.</p>
                            
                            new code sample
                            
                            <p>To review the order of rules determining precedence for our THIS binding from highest to lowest:</p>
                            <ol>
                            <li>The NEW constructor keyword</li>
                            <li>EXPLICIT binding - using bind(), call(), or apply() to set our THIS context</li>
                            <li>IMPLICIT binding - look to the left to determine ownership</li>
                            <li>DEFAULT binding - global object or undefined (strict vs non-strict mode)</li>
                            </ol>
                            <br>  
                            <h2>Closures</h2>
                            <p>Closures are another foggy concept for many new developers, and can be a bit to wrap your head around at first. They seem to evade our traditional concepts of variable scope and lifecycle. Simply put closures are a way to maintain state and access variables from an external scope after the initial function call has completed. They can be used to separate methods and functions into private and public interfaces through encapsulation. Using closures narrows our function scope, creates code that is easier to read, and increases efficiency by allowing us to maintain state of a variable
                            instead of having to recompute it for every instance, or alternatively having to keep track of, preserve and pass in a particular piece of data.</p>
                            
                            <p>Closures are a feature only available to functions, and are created by nesting one function within another, then by
                            passing the nested function a variable and exposing this preserved data to an external scope in a return statement.</p>
                            
                            <p>Closures can only truly be defined as closures if they can be observed, which means that the variable maintaining state must be accessed from an external scope in order to create the intended and observable effect. Closures provide direct access to manipulate the variable itself, as they provide us access by reference not by value and as commonly misinterpreted.</p>
                            
                            <p>Kyle Simpson's mental model in "You Dont KNow JS: Scopes and Closure" most accurately describes closures as: "a function instance and its scope environment
                            preserved in-place while any references or variables to it are passed around and invoked from other scopes."</p>
                            
                            Closure syntax example
                            
                            <p>Quick review: outer function, nested inner function, variable passed from outer function to inner function to maintain state, inner function exposes variable through return statement, scope external to outer function accesses inner data and variables. So now that we've explore closures understand lets move on to modules.</p>
                            <br>
                            <h2> ES Modules and the Module Pattern </h2>
                            <p>In early days of web programming, when the internet still consisted of primarily static web pages, js code was limited to single lines embedded in html to assemble web components. As it has slowly taken on a new role and expanded functionality to both front and back end development, and non-browser applications, javascript programs have increased in size and complexity, and with it the demand for a consistent load pattern for the use of multiple js files and resources within the same program. As our js files expand in size breaking code down into modules allow us to organize our code into smaller modular pieces, making programs easier to read, scale, debug, reuse components, implement a separation of concerns, and honor the privilege of least exposure, by encapsulating variables and methods into public and private interfaces. </p>
                            
                            <h3> The Classic Module Pattern</h3>
                            <p>Prior to ES6 Javascript did not have built-in modules, and solutions such as the use of an IIFE, UMDs(Universal Module Definition), AMDs(Asynchronous Module Definition), the Common JS pattern, and module bundlers evolved out of necessity. Before the creation of native JS modules we had to rely on enclosing functions and closures using the classic module pattern to group similar functions, retain state with within them, and to control access to private user interfaces.</p>
                        
                            </p>In order a for module to fit the characteristics of the classic module pattern Kyle Simpson (You Don't Know JS) reminds
                            us that it display the following characteristics:</p>
                            <ol>
                                <li>An outer scope from that runs at least once, </li>
                                <li>An inner scope that has at least one piece of hidden information</li>
                                <li>Must return a reference to at least one function that has closure over a hidden module state</li>
                            </ol>
                            
                            <p>Below is a syntax example I have create of the classic module pattern from my experimental app for scopes modules and closures, it includes the use of a function expression storing an IIFE that returns a public interface through its inner function by uses closure to make the return object keys storing stateful data.</p>
                            <br>
                            <pre>
                            
                            const CACHE = (function setCACHE(data) {
                                var cache = {};
                                function cacheData(data, cacheName) {
                                    if (data) { cache[cacheName] = data };
                                    return cache[cacheName];
                                };
                            
                                return {
                                    totalPrice: function (data) { return cacheData(data, 'totalPrice') },
                                    taxRate: function (data) { return cacheData(data, 'taxRate') },
                                    element: {
                                        price: document.getElementById('cost-num')
                                    }
                                }
                            })();

                            CACHE.totalPrice(2.33);

                            </pre>
                            <br>
                            <h3>ES Modules</h3>
                            <p>Since ES built-in modules were introduced in ES6 they have slowly found support across the browser landscape as they become the standardized native module format for javascript development. As of 2020 the only browsers still lagging in adopting ES modules are: Opera, Internet Explorer, and a few less commonly known and used outliers.</p>
                            
                            <p>ESMs are fairly simple and include 3 primary components, an export statement in the file containing module to be exported, an import statement in the top level js file that we are importing to, and a module script statement to be include in the html file. ES Modules do not require Immediately Invoked Function, or any fancy or mystical syntax.</p>

                            </p>Modules are singletons no matter how many times they are imported/exported only one instance is created at the top scope level, because ES modules are automatically created in 'strict-mode' and declarations are scoped to modules and not visible globally. Because modules are operating in strict mode and not available globally, this may limit accessibility to module features in the console and limit debugging capabilities for these objects.</p>
                            
                            </p>There are several variations including these three steps in our code, each with minor variations in syntax and
                            functionality. Named exports are the most straightforward use of ES modules. This ES module syntax is useful for
                            exporting/importing multiple objects from one file and to the top level js file of a program using the example shorthand syntax below. Don't forget we need to include the following three steps in any module variation: load the module file with a script tag in our html file, export the module using one of the es module variations, import the module into our top level file.</p>
                            <br>
                            <pre>
                            // Named exports:
                            
                            // modules/localStorage.js'
                            export { createNewList, buildSavedList, returnSavedList, manageGroceryList };
                            
                            // js/main.js
                            import { createNewList, buildSavedList, returnSavedList, manageGroceryList } from './modules/localStorage.js';
                            
                            // index.html
                            <script type="module" src="localStorage.js"></script>
                            </pre>
                            <h3>Default Exports</h3>
                            <p>Another variation of ES Modules is to use default exports. Default export we created to cooperate with UMD and Common JS modules. This syntax will only export ONE object per file.</p>
                            <br>
                            <pre>
                            // Default Exports:
                            
                            // js/modules/localStorage.js'
                            export default newList;
                            
                            // js/main.js
                            import newList from './modules/localStorage.js';
                            </pre>
                            <br>
                            
                            <h3>Renaming Exports</h3>
                            <p>Sometimes to avoid naming collisions we may have to rename our modules upon export:</p>
                            <br>
                            <pre>
                            // Renaming Module Exports
                            
                            // js/modules/localStorage.js'
                            export {
                                createNewList as newList,
                                buildSavedList as savedList
                            };
                            
                            // js/main.js
                            import { newList, savedList } from './modules/localStorage.js';
                            </pre>
                            <br>
                            <h3>Renaming Imports</h3> 
                            <p>ES6 has also provided us an option to alternatively rename modules upon import if we prefer:</p>
                            <br>
                            <pre>
                                // Renaming Module Imports
                                
                                // js/modules/localStorage.js'
                                export { createNewList, buildSavedList };
                                
                                // js/main.js
                                import {
                                    createNewList as newList,
                                    buildSavedList as savedList
                                } from './modules/localStorage.js';
                            </pre>
                            <br>
                            <h3> Module Objects</h3>
                            <p>The final module variation will will explore is the creating module objects. Using module object we include or named exports in our export file, and import everything, and reference our exported objects as properties of the imported module</p>
                            <br>
                            <pre>
                                // Creating Module Objects
                                
                                // js/modules/localStorage.js
                                export { createNewList, buildSavedList, returnSavedList, manageGroceryList };
                                
                                // js/main.js
                                import * as Storage from './modules/localStorage.js';
                                Storage.manageGroceryList('addItem', 'banana', 3);
                            </pre>
                            <br>
                            <h2>Deeper Exploration</h2>
                            <p>Whew. That was a lot to cover. If you are still here and want to explore these topic further I have two personal
                            favorites I would like to share here, one specifically for in-depth exploration and another for the full breadth of web development and javascript topics. The first resource as I have already mentioned above is the "You Don't Know JS" series by Kyle Simpson, now into it's second edition. These books can be purchased in hardcover on Amazon.com, or
                            digested for free electronically directly from the github repo: https://github.com/getify/You-Dont-Know-JS. While the
                            majority of the material covered in this blog post was based on "Scopes and Closure", other titles include: "Async and Performance", "Es6 & Beyond", "This and Object Prototypes", "Types and Grammar", and more. Alternatively if video instruction is more your learning style Kyle has some notable intermediate and advanced JS classes at
                            https://frontendmasters.com. The second resource is a github repo titled '33 Things Every Developer Should Know'. XXXadd link here XXX It is a thorough list of articles and video resources for exploring everything from to</p>
                            
                            <p>Good luck on your journey. I hope I was able to clarify some of these topics for you. If you found this blog post
                            helpful please like it, or share it with other developers you think could benefit, and follow me on Dev.to or check out my online portfolio at <a href='http://www.harleighabel.com'>http://harleighabel.com</a></p>

                            <p>The repository for the code samples were extracted from can be found <a href='https://www.youtube.com/watch?v=S64JOX8x_K8'>here!</a><br>
                            
                            A live demo of that application can be found <a href='https://www.joesgroceries.com'>here! </a>
                            <br><br>
                            <a href='https://github.com/atxrenegade'>atxrenegade/Harleigh Abel</a></p><br>
                            
                            <h3>References:</h3>
                            <p>All Things Javascript. “Function Declarations VS Function Expressions in JavaScript.” YouTube, 14 Oct. 2016,
                            www.youtube.com/watch?v=gjLn95skIKE.</p>
                            
                            <p>Code With Mosh. “JavaScript This Keyword.” YouTube, 15 May 2018, www.youtube.com/watch?v=gvicrj31JOM. Accessed 25 May 2020.</p>
                            
                            <p>Griffith, Steve. “JS Function Methods Call( ), Apply( ), and Bind( ).” YouTube, 10 Oct. 2017, www.youtube.com/watch?v=uBdH0iB1VDM.</p>
                            
                            <p>“JavaScript Modules.” MDN Web Docs, developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules. Accessed 25 May 2020.</p>
                            
                            <p>“JavaScript Runtime.” MDN Web Docs, developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino/JavaScript_runtime. Accessed 25 May 2020.</p>
                            
                            <p>Johansson, Mattias Petter. “JS Function Methods Call( ), Apply( ), and Bind( ).” YouTube, 10 Oct. 2017,
                            www.youtube.com/watch?v=uBdH0iB1VDM. Accessed 25 May 2020.</p>
                            
                            <p>Maldonado, Leonardo. “Leonardomso/33-Js-Concepts.” GitHub, 24 May 2020, github.com/leonardomso/33-js-concepts. Accessed 25 May 2020.</p>
                            
                            <p>“Phases of Compiler with Example.” Guru99.Com, 10 Dec. 2019, www.guru99.com/compiler-design-phases-of-compiler.html.</p>
                            
                            <p>Roberts, Phillip. “What the Heck Is the Event Loop Anyway? | Philip Roberts | JSConf EU.” YouTube, 9 Oct. 2014, www.youtube.com/watch?v=8aGhZQkoFbQ. Accessed 25 May 2020.</p>
                            
                            Simpson, Kyle. “Getify/You-Dont-Know-JS.” GitHub, 25 May 2020, github.com/getify/You-Dont-Know-JS.</p>
                            
                            <p>Techsith. “Javascript Closure Tutorial ( Closures Explained ).” YouTube, 18 Nov. 2015,
                            www.youtube.com/watch?v=71AtaJpJHw0. Accessed 25 May 2020.</p>
                            
                            <p>Wikipedia Contributors. “JavaScript.” Wikipedia, Wikimedia Foundation, 22 Mar. 2019, en.wikipedia.org/wiki/JavaScript.</p>
                            
                            <p>Zlatkov, Alexander. “How JavaScript Works: An Overview of the Engine, the Runtime, and the Call Stack.” Medium, 12 Dec. 2018, blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf. Accessed 25 May 2020.</p>

                            <img src='/img/blog/javascript2.jpg' alt='Coding in Javascript'>
                        </div>

                        <!--Blog Content End-->

                        <!--Blog Comments Start-->
                        <div class="blog-comments col-md-8 offset-md-2">
                            <h4 class="mb-40">Post Comments</h4>
                            <ul class="comment-list">
                            <!-- sample comment
                                <li class="comment">

                                    <div class="author-img">
                                        <img src="img/blog/authors/author-1.jpg" alt="">
                                    </div>
                                    <div class="comment-text">
                                        <span class="reply"><a href="#">Reply</a></span>
                                        <h6 class="author">Jane Doe</h6>
                                        <span class="date">June 10, 2018 at 5:39 am</span>
                                        <p>Deep v cliche lomo biodiesel Neutra selfies. Shorts fixie consequat flexitarian four loko </p>
                                    </div>

                                </li>
                            -->
                            </ul>
                        </div>
                        <!--Blog Comments End-->

                        <div class="comment-form col-lg-8 offset-lg-2">

                            <h4 class="mt-40 mb-40">Leave A Reply</h4>
                            <form action="#">

                                <div class="row">
                                    <!--Name Field-->
                                    <div class="col-md-6 mb-50">
                                        <span class="input">
                                            <input class="input__field" type="text" id="name" name="name" required/>
                                            <label class="input__label" for="name">Name</label>
                                        </span>
                                    </div>

                                    <!--Email Field-->
                                    <div class="col-md-6 mb-50">
                                        <span class="input">
                                            <input class="input__field" type="text" id="email" name="email" required/>
                                            <label class="input__label" for="email">Email</label>
                                        </span>
                                    </div>

                                    <!--Message Box-->
                                    <div class="col-md-12 mb-30">
                                        <span class="input">
                                            <textarea  class="input__field" id="message" name="message" rows="5" required></textarea>
                                            <label class="input__label" for="message">Your Comment</label>
                                        </span>
                                    </div>

                                    <!--Submit Button-->
                                    <div class="col-md-12">
                                        <button class="btn-main">Post Comment</button>
                                    </div>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!--Jquery JS-->
    <script src="js/jquery.min.js"></script>
    <!--Plugins JS-->
    <script src="js/plugins.min.js"></script>
    <!--Site Main JS-->
    <script src="js/main.js"></script>

    </body>
</html>
